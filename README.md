# JavaScript Recipes

## Table of Contents

### Algorithms

- **Sorting**
  - Bubble Sort
  - Counting Sort
  - Merge Sort
  - Quick Sort
  - Radix Sort
- **Searching**
  - Binary Search
  - Fast Linear Search
  - Interpolation Search
  - Linear Search

### Arrays and Collections

- **Arrays**
  - Adding and Removing Elements
  - Array Copying
  - Array Length
  - Array with Default Value
  - Comparing Arrays
  - Arrays Initialization
  - Arrays Merging
  - Checking Equality of Arrays
  - Converting an Array
  - Dynamic Arrays
  - Filtering Elements
  - Finding an Array Element
  - Getting Min and Max Values
  - Getting Part of an Array
  - Getting Unique Values
  - Iterating Over an Array
  - Iterating Over an Array with Index
  - Sorting of Elements
  - `every()` and `some()` Methods
- **Dictionaries**
  - Adding and Removing Elements
  - Amount of Elements
  - Checking Presence of a Key
  - Converting a Dictionary
  - Default Value
  - Dictionaries Initialization
  - Dictionary Merge
  - Filtering Elements
  - Get Value by Key
  - Getting Keys by Value
  - Getting a List of Keys
  - Getting a List of Values
  - Grouping Collection
  - Iterating Over a Dictionary
  - Sort Dictionary by Keys
  - Sort Dictionary by Values
- **Iterators**
  - Reverse Iterator
  - Simple Iterator
- **Queue (FIFO)**
- **Sets**
  - Adding and Removing Elements
  - Converting a Set
  - Filtering Elements
  - Iterating Over a Set
  - Search for an Element
  - Set Comparison
  - Sets Initialization
  - Sets Operations
  - Sorted Set
  - Sorting of Elements
- **Stacks (LIFO)**

### Control Flow

- **Conditional Statements**
  - If/Else Statements
    - Complex Conditions
    - Ternary Operator
  - Switch/Case Statements
    - Different Types of Values
    - Simple Conditions
    - Without the `break` Operator
- **Interruption of Control Flow**
  - Break Statement
  - Continue Statement
  - Return Statement
  - Labeled Statement
- **Loops**
  - Do-While Loop
  - For Loop
  - For-In Loop
  - For-Of Loop
  - ForEach Loop
  - While Loop
  - Endless Loop
- **Other Operations**
  - Debugger Statement
  - With Statement

### Enumerations

- Base Member Value
- Base Type
- Conversion from a String
- Converting to a String
- Definition and Initialization
- Enum Comparison
- Explicitly Set Base Value
- Get the List of Values
- Initializing from a Base Value

### Exceptions Handlin

- Catch All Exceptions
- Catch a Specific Exception
- Define an Exception Type
- Guaranteed Code Execution
- Method Throwing an Exception
- Re-Throw Exceptions
- Throw an Exception

### Extensions

- Adding Object Methods
- Adding Properties
- Adding Type Methods
- Simple Types Extension

### Functions

- Array of Parameters
- In/Out Parameters
- Multiple Return Values
- Optional Parameter Values
- Recursion
- Variable Parameters
- With Return Value
- Without Any Parameters
- Without Any Return Value

### Generic Types

- Generic Classes
- Generic Methods
- Substitution Principle

### Initializing of Types

- Classes
  - With a Constructor
  - Without Any Constructor
- Collections
  - Arrays
  - Dictionaries
  - Set

### Differences Between `var` and `let`

### Enumerations

- Simple Types
- Structures
  - Without Any Constructor
- Interfaces
  - Conformance Checking (is, as)
  - Constructor Requirements
  - Declaration and Initialization
  - Interfaces Collection
  - Interfaces Inheritance
  - Methods Requirements
  - Properties Requirements

### Lambda Expressions

- Capture of Variables
- Currying
- Function as a Parameter
- Function as a Return Value
- Memoization
- Memoization (Recursive)
- Modify Captured Variable
- Recursion
- With Multiple Operators
- With Multiple Parameters
- With One Parameter
- Without Return Value

### Multi-Threaded Operations

- Asynchronous Call
- Asynchronous Call with a Result
- Error Handling
- Keywords `async` and `await`
- Start of a New Thread
- Start of a New Thread and Waiting
- Operators Overloading

### Design Patterns

- **Behavioral Patterns**
  - Chain of Responsibility
  - Command
  - Interpreter
  - Iterator
  - Mediator
  - Memento
  - Observer
  - State
  - Strategy
  - Template Method
  - Visitor
- **Creational Patterns**
  - Abstract Factory
  - Builder
  - Factory Method
  - Prototype
  - Singleton
- **Structural Patterns**
  - Adapter (Composition)
  - Adapter (Inheritance)
  - Bridge
  - Composite
  - Decorator
  - Facade
  - Flyweight
  - Proxy

### Regular Expressions

- Check Match String
- Check Match Whole String
- Named Groups
- Regular Expression Options
- Replacement of the Match
- Replacement Using a Function
- Search All Matches
- Search for a Match

### Structures (Records)

- Constants
- Constructors
- Definition and Initialization
- Fields and Properties
- Methods
- Structure Inside the Structure
- Type Members

### Universal (Dynamic) Types

- Call Type Members
- Initialization
- Return Value

### Work with Color

- Color to HTML Color
- Color to RGB
- HTML Color to RGB
- RGB to Color

### Work with Database (DB)

- Connect to the DB
  - Connect to Firebird
  - Connect to MySQL
  - Connect to Oracle
  - Connect to PostgreSQL
  - Connect to SQL Server
  - Connect to SQLite
- Execute SQL Command
- Execute SQL Query
- SQL Query with Parameters

### Work with Files

- **Archives**
  - Packing a Zip File
  - Packing a Zip File with a Password
  - Unpacking a Zip File
- **Basic Operations**
  - Check If the File Exists
  - Copy a Directory
  - Create a Directory
  - Delete a Directory
  - Delete a Directory with Data
  - Delete a File
  - File Copying
  - File Moving
  - Get the Working Directory
  - Getting File Properties
  - List of Files in the Directory
- **Binary Files**
  - Read Array from a File
  - Read Dictionary from a File
  - Reading a Binary File
  - Write Array to a File
  - Write Dictionary to a File
  - Writing a Binary File
- **Text Files**
  - Append Text to a File
  - Read File Line by Line
  - Read from a File
  - Write to a File
- **XML Files**
  - Reading an XML File

### Work with Simple Types

- **Boolean**
  - Conversion from a String
  - Converting to a String
  - Getting Values
  - Logical Operations
- **Character Type**
  - Converting to a Number and Back
  - Converting to a String
  - Escape Characters
  - Getting from a String
- **Date and Time**
  - Comparison of Dates
  - Conversion from a String
  - Converting to a String
  - Date Changing
  - Date Initialization
  - Getting the Current Date
  - Getting Year, Month, Day
  - The Interval Between Dates
- **Nullable Types**
  - Checking Presence of a Value
  - Initialization
- **Numbers**
  - **Double and Float**
    - Arithmetic Operations
    - Conversion from a String
    - Converting to a String
    - Converting to Integer
    - Getting Random Values
    - Rounding and Truncating
  - **Integers**
    - Arithmetic Operations
    - BigInteger
    - Bitwise Operations
    - Conversion from a String
    - Converting to a String
    - Getting Random Values
    - Numerical System
  - **Mathematical Operations**
    - Decimal Logarithm
    - Exponentiation
    - Logarithm
    - Sine, Cosine, and Tangent
    - Square Root
    - Min and Max Values
- **Strings**
  - Change the Case of Characters
  - Character Replacement
  - Characters Count
  - Converting to a Number
  - Empty Strings
  - Escaping Characters
  - Getting Substring
  - Iterating Over a String
  - Removing Spaces
  - Replace Multiple Characters
  - Split Into an Array
  - String Multiplication
  - String Padding
  - Strings Comparison
  - Strings Concatenating
  - String Interpolation
  - String List Concatenating
  - Substring Index
  - Substring Inserting
  - Substring Removing
  - Substring Replacement
  - Substring Searching
- **Tuple**
  This structure should help organize your JavaScript recipes guide effectively.

### Algorithms

Algorithms are step-by-step procedures for solving specific problems or performing tasks. They are crucial in computer science and programming for efficient problem-solving.
**Bubble Sort:** Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.
// Bubble Sort Example
function bubbleSort(arr) {
const n = arr.length;
for (let i = 0; i < n - 1; i++) {
for (let j = 0; j < n - i - 1; j++) {
if (arr[j] > arr[j + 1]) {
// Swap the elements
let temp = arr[j];
arr[j] = arr[j + 1];
arr[j + 1] = temp;
}
}
}
return arr;
}

    const exampleArray = [64, 34, 25, 12, 22, 11, 90];
    const sortedArray = bubbleSort(exampleArray);
    console.log(sortedArray); // Output: [11, 12, 22, 25, 34, 64, 90]

**Counting Sort:** Counting Sort is an integer sorting algorithm that works by counting the number of occurrences of each element and using that information to place elements in sorted order.

    // Counting Sort Example
    function countingSort(arr) {
      const max = Math.max(...arr);
      const count = Array(max + 1).fill(0);
      const output = [];

      for (let i = 0; i < arr.length; i++) {
        count[arr[i]]++;
      }

      for (let i = 0; i <= max; i++) {
        while (count[i] > 0) {
          output.push(i);
          count[i]--;
        }
      }

      return output;
    }

    const exampleArray = [4, 2, 2, 8, 3, 3, 1];
    const sortedArray = countingSort(exampleArray);
    console.log(sortedArray); // Output: [1, 2, 2, 3, 3, 4, 8]

**Merge Sort:** Merge Sort is a divide-and-conquer sorting algorithm that divides an array into smaller sub-arrays, sorts them, and then merges them back together.

    // Merge Sort Example
    function mergeSort(arr) {
      if (arr.length <= 1) return arr;

      const mid = Math.floor(arr.length / 2);
      const left = arr.slice(0, mid);
      const right = arr.slice(mid);

      const merge = (left, right) => {
        const result = [];
        let leftIndex = 0;
        let rightIndex = 0;

        while (leftIndex < left.length && rightIndex < right.length) {
          if (left[leftIndex] < right[rightIndex]) {
            result.push(left[leftIndex]);
            leftIndex++;
          } else {
            result.push(right[rightIndex]);
            rightIndex++;
          }
        }

        return result.concat(left.slice(leftIndex), right.slice(rightIndex));
      };

      return merge(mergeSort(left), mergeSort(right));
    }

    const exampleArray = [38, 27, 43, 3, 9, 82, 10];
    const sortedArray = mergeSort(exampleArray);
    console.log(sortedArray); // Output: [3, 9, 10, 27, 38, 43, 82]

**Quick Sort:** Quick Sort is another divide-and-conquer sorting algorithm that works by selecting a "pivot" element and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot.

    // Quick Sort Example
    function quickSort(arr) {
      if (arr.length <= 1) return arr;

      const pivot = arr[arr.length - 1];
      const left = [];
      const right = [];

      for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] < pivot) {
          left.push(arr[i]);
        } else {
          right.push(arr[i]);
        }
      }

      return [...quickSort(left), pivot, ...quickSort(right)];
    }

    const exampleArray = [38, 27, 43, 3, 9, 82, 10];
    const sortedArray = quickSort(exampleArray);
    console.log(sortedArray); // Output: [3, 9, 10, 27, 38, 43, 82]

**Radix Sort:** Radix Sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by individual digits that share the same significant position.

    // Radix Sort Example
    function radixSort(arr) {
      const max = Math.max(...arr);
      let exp = 1;

      while (Math.floor(max / exp) > 0) {
        countingSortByDigit(arr, exp);
        exp *= 10;
      }

      return arr;
    }

    function countingSortByDigit(arr, exp) {
      const output = Array(arr.length).fill(0);
      const count = Array(10).fill(0);

      for (let i = 0; i < arr.length; i++) {
        count[Math.floor(arr[i] / exp) % 10]++;
      }

      for (let i = 1; i < 10; i++) {
        count[i] += count[i - 1];
      }

      for (let i = arr.length - 1; i >= 0; i--) {
        output[count[Math.floor(arr[i] / exp) % 10] - 1] = arr[i];
        count[Math.floor(arr[i] / exp) % 10]--;
      }

      for (let i = 0; i < arr.length; i++) {
        arr[i] = output[i];
      }
    }

    const exampleArray = [170, 45, 75, 90, 802, 24, 2, 66];
    const sortedArray = radixSort(exampleArray);
    console.log(sortedArray); // Output: [2, 24, 45, 66, 75, 90, 170, 802]
