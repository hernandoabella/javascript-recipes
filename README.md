# JavaScript Recipes üë®‚Äçüç≥

## Table of Contents

### Algorithms

- **Sorting**
  - Bubble Sort
  - Counting Sort
  - Merge Sort
  - Quick Sort
  - Radix Sort
- **Searching**
  - Binary Search
  - Fast Linear Search
  - Interpolation Search
  - Linear Search

### Arrays and Collections

- **Arrays**
  - Adding and Removing Elements
  - Array Copying
  - Array Length
  - Array with Default Value
  - Comparing Arrays
  - Arrays Initialization
  - Arrays Merging
  - Checking Equality of Arrays
  - Converting an Array
  - Dynamic Arrays
  - Filtering Elements
  - Finding an Array Element
  - Getting Min and Max Values
  - Getting Part of an Array
  - Getting Unique Values
  - Iterating Over an Array
  - Iterating Over an Array with Index
  - Sorting of Elements
  - `every()` and `some()` Methods
- **Dictionaries**
  - Adding and Removing Elements
  - Amount of Elements
  - Checking Presence of a Key
  - Converting a Dictionary
  - Default Value
  - Dictionaries Initialization
  - Dictionary Merge
  - Filtering Elements
  - Get Value by Key
  - Getting Keys by Value
  - Getting a List of Keys
  - Getting a List of Values
  - Grouping Collection
  - Iterating Over a Dictionary
  - Sort Dictionary by Keys
  - Sort Dictionary by Values
- **Iterators**
  - Reverse Iterator
  - Simple Iterator
- **Queue (FIFO)**
- **Sets**
  - Adding and Removing Elements
  - Converting a Set
  - Filtering Elements
  - Iterating Over a Set
  - Search for an Element
  - Set Comparison
  - Sets Initialization
  - Sets Operations
  - Sorted Set
  - Sorting of Elements
- **Stacks (LIFO)**

### Classes
- Check for reference equality
- Constants
- Constructors
  - Call of the own constructor
  - Call of the parent constructor
  - Default constructor
  - Optional parameter values
  - Replacement of the parent constructor
  - With parameters
  - Without any parameters
- Create a copy of the object
- Definition and initialization
- Events
- Fields
- Inhiritance
 - Abstract classes
 - Base class
 - Compability check (is)
 - Members hiding
 - Method override
 - Private class members
 - Property override
 - Sealed class members
- Methods
 - Array of parameters
 - Class methods
 - In/Out parameters
 - Multiple return values
 - Optional parameter values
 - Variable parameters
 - With return value
 - Without return value
 - Without any parameters
 - Without any return value
- Nested class
- Properties
 - Computed properties
 - Lazy properties
 - Ready-Only properties
  - Computed properties
  - Stored properties
 - Stored properties
 - Type properties
- Type members

### Control Flow

- **Conditional Statements**
  - If/Else Statements
    - Complex Conditions
    - Ternary Operator
  - Switch/Case Statements
    - Different Types of Values
    - Simple Conditions
    - Without the `break` Operator
- **Interruption of Control Flow**
  - Break Statement
  - Continue Statement
  - Return Statement
  - Labeled Statement
- **Loops**
  - Do-While Loop
  - For Loop
  - For-In Loop
  - For-Of Loop
  - ForEach Loop
  - While Loop
  - Endless Loop
- **Other Operations**
  - Debugger Statement
  - With Statement

### Enumerations

- Base Member Value
- Base Type
- Conversion from a String
- Converting to a String
- Definition and Initialization
- Enum Comparison
- Explicitly Set Base Value
- Get the List of Values
- Initializing from a Base Value

### Exceptions Handlin

- Catch All Exceptions
- Catch a Specific Exception
- Define an Exception Type
- Guaranteed Code Execution
- Method Throwing an Exception
- Re-Throw Exceptions
- Throw an Exception

### Extensions

- Adding Object Methods
- Adding Properties
- Adding Type Methods
- Simple Types Extension

### Functions

- Array of Parameters
- In/Out Parameters
- Multiple Return Values
- Optional Parameter Values
- Recursion
- Variable Parameters
- With Return Value
- Without Any Parameters
- Without Any Return Value

### Generic Types

- Generic Classes
- Generic Methods
- Substitution Principle

### Initializing of Types

- Classes
  - With a Constructor
  - Without Any Constructor
- Collections
  - Arrays
  - Dictionaries
  - Set

### Differences Between `var` and `let`

### Enumerations

- Simple Types
- Structures
  - Without Any Constructor
- Interfaces
  - Conformance Checking (is, as)
  - Constructor Requirements
  - Declaration and Initialization
  - Interfaces Collection
  - Interfaces Inheritance
  - Methods Requirements
  - Properties Requirements

### Lambda Expressions

- Capture of Variables
- Currying
- Function as a Parameter
- Function as a Return Value
- Memoization
- Memoization (Recursive)
- Modify Captured Variable
- Recursion
- With Multiple Operators
- With Multiple Parameters
- With One Parameter
- Without Return Value

### Multi-Threaded Operations

- Asynchronous Call
- Asynchronous Call with a Result
- Error Handling
- Keywords `async` and `await`
- Start of a New Thread
- Start of a New Thread and Waiting
- Operators Overloading

### Design Patterns

- **Behavioral Patterns**
  - Chain of Responsibility
  - Command
  - Interpreter
  - Iterator
  - Mediator
  - Memento
  - Observer
  - State
  - Strategy
  - Template Method
  - Visitor
- **Creational Patterns**
  - Abstract Factory
  - Builder
  - Factory Method
  - Prototype
  - Singleton
- **Structural Patterns**
  - Adapter (Composition)
  - Adapter (Inheritance)
  - Bridge
  - Composite
  - Decorator
  - Facade
  - Flyweight
  - Proxy

### Regular Expressions

- Check Match String
- Check Match Whole String
- Named Groups
- Regular Expression Options
- Replacement of the Match
- Replacement Using a Function
- Search All Matches
- Search for a Match

### Structures (Records)

- Constants
- Constructors
- Definition and Initialization
- Fields and Properties
- Methods
- Structure Inside the Structure
- Type Members

### Universal (Dynamic) Types

- Call Type Members
- Initialization
- Return Value

### Work with Color

- Color to HTML Color
- Color to RGB
- HTML Color to RGB
- RGB to Color

### Work with Database (DB)

- Connect to the DB
  - Connect to Firebird
  - Connect to MySQL
  - Connect to Oracle
  - Connect to PostgreSQL
  - Connect to SQL Server
  - Connect to SQLite
- Execute SQL Command
- Execute SQL Query
- SQL Query with Parameters

### Work with Files

- **Archives**
  - Packing a Zip File
  - Packing a Zip File with a Password
  - Unpacking a Zip File
- **Basic Operations**
  - Check If the File Exists
  - Copy a Directory
  - Create a Directory
  - Delete a Directory
  - Delete a Directory with Data
  - Delete a File
  - File Copying
  - File Moving
  - Get the Working Directory
  - Getting File Properties
  - List of Files in the Directory
- **Binary Files**
  - Read Array from a File
  - Read Dictionary from a File
  - Reading a Binary File
  - Write Array to a File
  - Write Dictionary to a File
  - Writing a Binary File
- **Text Files**
  - Append Text to a File
  - Read File Line by Line
  - Read from a File
  - Write to a File
- **XML Files**
  - Reading an XML File

### Work with Simple Types

- **Boolean**
  - Conversion from a String
  - Converting to a String
  - Getting Values
  - Logical Operations
- **Character Type**
  - Converting to a Number and Back
  - Converting to a String
  - Escape Characters
  - Getting from a String
- **Date and Time**
  - Comparison of Dates
  - Conversion from a String
  - Converting to a String
  - Date Changing
  - Date Initialization
  - Getting the Current Date
  - Getting Year, Month, Day
  - The Interval Between Dates
- **Nullable Types**
  - Checking Presence of a Value
  - Initialization
- **Numbers**
  - **Double and Float**
    - Arithmetic Operations
    - Conversion from a String
    - Converting to a String
    - Converting to Integer
    - Getting Random Values
    - Rounding and Truncating
  - **Integers**
    - Arithmetic Operations
    - BigInteger
    - Bitwise Operations
    - Conversion from a String
    - Converting to a String
    - Getting Random Values
    - Numerical System
  - **Mathematical Operations**
    - Decimal Logarithm
    - Exponentiation
    - Logarithm
    - Sine, Cosine, and Tangent
    - Square Root
    - Min and Max Values
- **Strings**
  - Change the Case of Characters
  - Character Replacement
  - Characters Count
  - Converting to a Number
  - Empty Strings
  - Escaping Characters
  - Getting Substring
  - Iterating Over a String
  - Removing Spaces
  - Replace Multiple Characters
  - Split Into an Array
  - String Multiplication
  - String Padding
  - Strings Comparison
  - Strings Concatenating
  - String Interpolation
  - String List Concatenating
  - Substring Index
  - Substring Inserting
  - Substring Removing
  - Substring Replacement
  - Substring Searching
- **Tuple**
  This structure should help organize your JavaScript recipes guide effectively.

## Algorithms

Algorithms are step-by-step procedures for solving specific problems or performing tasks. They are crucial in computer science and programming for efficient problem-solving.

### Sorting Algorithms:

**Bubble Sort:** Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.

```
function bubbleSort(arr) {
  const len = arr.length;
  let swapped;

  do {
    swapped = false;

    for (let i = 0; i < len - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        // Swap the elements
        const temp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = temp;
        swapped = true;
      }
    }
  } while (swapped);

  return arr;
}

// Example usage:
const unsortedArray = [64, 34, 25, 12, 22, 11, 90];
const sortedArray = bubbleSort(unsortedArray);
console.log(sortedArray); // [ 11, 12, 22, 25, 34, 64, 90 ]
```

**Counting Sort:** Counting Sort is an integer sorting algorithm that works by counting the number of occurrences of each element and using that information to place elements in sorted order.

```
function countingSort(arr) {
  // Find the maximum element in the input array
  const max = Math.max(...arr);

  // Create an array to store the count of each element
  const countArray = new Array(max + 1).fill(0);

  // Count the occurrences of each element in the input array
  for (let i = 0; i < arr.length; i++) {
    countArray[arr[i]]++;
  }

  // Reconstruct the sorted array using the count information
  const sortedArray = [];
  for (let i = 0; i < countArray.length; i++) {
    while (countArray[i] > 0) {
      sortedArray.push(i);
      countArray[i]--;
    }
  }

  return sortedArray;
}

// Example usage:
const unsortedArray = [4, 2, 2, 8, 3, 3, 1];
const sortedArray = countingSort(unsortedArray);
console.log(sortedArray); // [ 1, 2, 2, 3, 3, 4, 8 ]
```

**Merge Sort:** Merge Sort is a divide-and-conquer sorting algorithm that divides an array into smaller sub-arrays, sorts them, and then merges them back together.

```
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  // Split the input array into two halves
  const middle = Math.floor(arr.length / 2);
  const leftHalf = arr.slice(0, middle);
  const rightHalf = arr.slice(middle);

  // Recursively sort the two halves
  const sortedLeft = mergeSort(leftHalf);
  const sortedRight = mergeSort(rightHalf);

  // Merge the sorted halves back together
  return merge(sortedLeft, sortedRight);
}

function merge(left, right) {
  let result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // Compare elements from both halves and add the smaller one to the result
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  // Concatenate any remaining elements from both halves (if any)
  return result.concat(left.slice(leftIndex), right.slice(rightIndex));
}

// Example usage:
const unsortedArray = [38, 27, 43, 3, 9, 82, 10];
const sortedArray = mergeSort(unsortedArray);
console.log(sortedArray);
```

**Quick Sort:** Quick Sort is another divide-and-conquer sorting algorithm that works by selecting a "pivot" element and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot.

```
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  // Select a pivot element (usually the first or last element)
  const pivot = arr[Math.floor(arr.length / 2)];

  // Divide the array into two sub-arrays: elements less than the pivot and elements greater than the pivot
  const left = arr.filter((element) => element < pivot);
  const middle = arr.filter((element) => element === pivot);
  const right = arr.filter((element) => element > pivot);

  // Recursively sort the sub-arrays and concatenate them
  return quickSort(left).concat(middle, quickSort(right));
}

// Example usage:
const unsortedArray = [38, 27, 43, 3, 9, 82, 10];
const sortedArray = quickSort(unsortedArray);
console.log(sortedArray); // [ 3, 9, 10, 27, 38, 43, 82 ]
```

**Radix Sort:** Radix Sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by individual digits that share the same significant position.

```
function radixSort(arr) {
  const max = Math.max(...arr);
  const maxDigitCount = getMaxDigitCount(max);

  for (let digitPlace = 0; digitPlace < maxDigitCount; digitPlace++) {
    const digitBuckets = Array.from({ length: 10 }, () => []);

    for (let i = 0; i < arr.length; i++) {
      const digit = getDigit(arr[i], digitPlace);
      digitBuckets[digit].push(arr[i]);
    }

    arr = [].concat(...digitBuckets);
  }

  return arr;
}

// Helper function to get the maximum number of digits in an array of integers
function getMaxDigitCount(num) {
  if (num === 0) return 1;
  return Math.floor(Math.log10(Math.abs(num))) + 1;
}

// Helper function to get the digit at a given place value
function getDigit(num, place) {
  return Math.floor(Math.abs(num) / Math.pow(10, place)) % 10;
}

// Example usage:
const unsortedArray = [170, 45, 75, 90, 802, 24, 2, 66];
const sortedArray = radixSort(unsortedArray);
console.log(sortedArray); // [ 2, 24, 45, 66, 75, 90, 170, 802 ]
```

### Searching Algorithms:

**Binary Search:** Binary search is a widely used search algorithm that efficiently finds a specific target value within a sorted array.

```
function binarySearch(arr, target) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    // Calculate the middle index of the current search interval
    const mid = Math.floor((left + right) / 2);

    // Check if the middle element is the target
    if (arr[mid] === target) {
      return mid; // Target found, return its index
    } else if (arr[mid] < target) {
      // If the target is greater, narrow the search to the right half
      left = mid + 1;
    } else {
      // If the target is smaller, narrow the search to the left half
      right = mid - 1;
    }
  }

  return -1; // Target not found
}

// Example usage:
const sortedArray = [2, 4, 7, 10, 23, 45, 56, 67, 78];
const targetValue = 23;
const result = binarySearch(sortedArray, targetValue);

if (result !== -1) {
  console.log(`Element found at index ${result}`);
} else {
  console.log("Element not found in the array");
}
// Element found at index 4
```

**Fast Linear Search:** A "Fast Linear Search" may refer to an optimized version of the linear search algorithm. Linear search, also known as sequential search, involves checking each element in a collection one by one until a match is found or the end of the collection is reached. It's not the most efficient search algorithm for large datasets but can be optimized in some cases.

```
function fastLinearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i; // Return the index of the target if found
    }
  }
  return -1; // Return -1 if the target is not found
}

// Example usage:
const arrayToSearch = [2, 4, 7, 10, 23, 45, 56, 67, 78];
const targetValue = 23;
const result = fastLinearSearch(arrayToSearch, targetValue);

if (result !== -1) {
  console.log(`Element found at index ${result}`); // Element found at index 4
} else {
  console.log("Element not found in the array");
}
```

**Interpolation Search:** Interpolation Search is an advanced searching algorithm that is used to search for a specific target value within a sorted array of values.

```
function interpolationSearch(arr, target) {
  let low = 0;
  let high = arr.length - 1;

  while (low <= high && target >= arr[low] && target <= arr[high]) {
    // Estimate the probable position of the target value
    const pos = low + Math.floor(((target - arr[low]) * (high - low)) / (arr[high] - arr[low]));

    if (arr[pos] === target) {
      return pos; // Target found
    } else if (arr[pos] < target) {
      low = pos + 1; // Narrow the search to the right half
    } else {
      high = pos - 1; // Narrow the search to the left half
    }
  }

  return -1; // Target not found
}

// Example usage:
const sortedArray = [2, 4, 7, 10, 23, 45, 56, 67, 78];
const targetValue = 23;
const result = interpolationSearch(sortedArray, targetValue);

if (result !== -1) {
  console.log(`Element found at index ${result}`);
} else {
  console.log("Element not found in the array");
}
// Element found at index 4
```

**Linear Search:** Linear Search, also known as sequential search, is a simple searching algorithm used to find a specific target value within a collection, such as an array or list.

```
function linearSearch(arr, target) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      return i; // Return the index of the target if found
    }
  }
  return -1; // Return -1 if the target is not found in the array
}

// Example usage:
const arrayToSearch = [2, 4, 7, 10, 23, 45, 56, 67, 78];
const targetValue = 23;
const result = linearSearch(arrayToSearch, targetValue);

if (result !== -1) {
  console.log(`Element found at index ${result}`); // Element found at index 4
} else {
  console.log("Element not found in the array");
}
```

## Arrays and Collections:

Arrays and collections are both data structures used to store and manage collections of elements or objects in programming.

### Arrays:

**Adding Elements:** You can add elements to the end of an array using the push() method.

```
const colors = ['red', 'blue'];
colors.push('green'); // Adds 'green' to the end
```

**Removing Elements:** You can remove elements from the end of an array using the pop() method.

```
const colors = ['red', 'blue', 'green'];
const removedColor = colors.pop(); // Removes 'green' from the end
```

**Array Copying:** To create a shallow copy of an array, you can use the spread operator (...) or the slice() method.

```
const originalArray = [1, 2, 3];
const copy1 = [...originalArray]; // Shallow copy using spread
const copy2 = originalArray.slice(); // Shallow copy using slice
```

**Array Length:** You can get the length of an array using the length property.

```
const fruits = ['apple', 'banana', 'cherry'];
const length = fruits.length; // Returns 3
```

**Array with Default Value:** You can create an array with a specific length and default values using the fill() method.

```
const defaultArray = new Array(5).fill(0); // Creates [0, 0, 0, 0, 0]
```

**Comparing Arrays:** To compare two arrays for equality, you can't use == or ===. You need to compare their elements manually.

```
const arr1 = [1, 2, 3];
const arr2 = [1, 2, 3];
const areEqual = JSON.stringify(arr1) === JSON.stringify(arr2); // Compares element values
```

**Arrays Initialization:** You can initialize an array with values using array literals.

```
const numbers = [1, 2, 3, 4, 5];
```

**Arrays Merging:** To merge two or more arrays into one, you can use the concat() method or the spread operator (...).

```
const arr1 = [1, 2];
const arr2 = [3, 4];
const mergedArray = arr1.concat(arr2); // or [...arr1, ...arr2]
```

**Checking Equality of Arrays:** You can check if two arrays are equal by comparing their contents.

```
function arraysEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) return false;
  for (let i = 0; i < arr1.length; i++) {
    if (arr1[i] !== arr2[i]) return false;
  }
  return true;
}
```

**Converting an Array:** You can convert an array to a string using the join() method.

```
const fruits = ['apple', 'banana', 'cherry'];
const fruitString = fruits.join(', '); // Converts to 'apple, banana, cherry'
```

**Dynamic Arrays:** JavaScript arrays are dynamic, meaning they can grow or shrink as needed.

```
const numbers = [];
numbers.push(1); // Adds an element
numbers.pop(); // Removes the last element
```

**Filtering Elements:** You can filter elements from an array that meet specific criteria using the filter() method.

```
const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(num => num % 2 === 0); // Filters even numbers
```

**Finding an Array Element:** You can find an element in an array using the find() method.

```
const fruits = ['apple', 'banana', 'cherry'];
const foundFruit = fruits.find(fruit => fruit === 'banana'); // Returns 'banana'
```

**Getting Min and Max Values:** You can find the minimum and maximum values in an array using the Math.min() and Math.max() functions with the spread operator (...).

```
const numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3];
const minValue = Math.min(...numbers); // Returns 1
const maxValue = Math.max(...numbers); // Returns 9
```

**Getting Part of an Array:** You can get a portion of an array using the slice() method.

```
const fruits = ['apple', 'banana', 'cherry', 'date'];
const selectedFruits = fruits.slice(1, 3); // Returns ['banana', 'cherry']
```

**Getting Unique Values:** To get unique values from an array, you can use the Set object or the filter() method.

```
const numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4];
const uniqueNumbers = [...new Set(numbers)]; // Returns [1, 2, 3, 4]
```

**Iterating Over an Array:** You can iterate over the elements of an array using a for loop or the forEach() method.

```
const fruits = ['apple', 'banana', 'cherry'];
for (let i = 0; i < fruits.length; i++) {
  console.log(fruits[i]);
}

// Using forEach:
fruits.forEach(fruit => console.log(fruit));
```

**Iterating Over an Array with Index:** You can iterate over an array with both elements and their indices using the forEach() method.

```
const fruits = ['apple', 'banana', 'cherry'];
fruits.forEach((fruit, index) => {
  console.log(`Index ${index}: ${fruit}`);
});
```

**Sorting of Elements:** You can sort the elements of an array using the sort() method. By default, it sorts elements alphabetically.

```
const fruits = ['banana', 'cherry', 'apple'];
fruits.sort(); // Sorts to ['apple', 'banana', 'cherry']
```

**every() and some() Methods:** The every() method checks if all elements in an array pass a given test, while the some() method checks if at least one element passes the test.

```
const numbers = [1, 2, 3, 4, 5];
const allEven = numbers.every(num => num % 2 === 0); // Checks if all are even
const someEven = numbers.some(num => num % 2 === 0); // Checks if some are even
```

### Dictionaries:

**Adding Elements:** To add a key-value pair to a dictionary, simply assign a value to a new key.

```
const person = {};
person.name = 'John';
person.age = 30;
```

**Removing Elements:** To remove a key-value pair, you can use the delete keyword.

```
delete person.age; // Removes the 'age' key and its value
```

**Amount of Elements:** You can get the number of key-value pairs in a dictionary using the Object.keys() method.

```
const person = { name: 'John', age: 30 };
const numberOfKeys = Object.keys(person).length; // Returns 2
```

**Checking Presence of a Key:** You can check if a key exists in a dictionary using the hasOwnProperty() method.

```
if (person.hasOwnProperty('name')) {
  // 'name' key exists in the dictionary
}
```

**Converting a Dictionary:** You can convert a dictionary to a string or JSON using JSON.stringify().

```
const person = { name: 'John', age: 30 };
const personJSON = JSON.stringify(person); // Converts to JSON string
```

**Default Value:** You can provide a default value when accessing a key to handle cases where the key doesn't exist.

```
const person = {};
const name = person.name || 'Default Name'; // Uses 'Default Name' as a default
```

**Dictionaries Initialization:** You can initialize a dictionary with key-value pairs using object literals.

```
const person = { name: 'John', age: 30 };
```

**Dictionary Merge:** You can merge two dictionaries using the spread operator (...).

```
const person1 = { name: 'John' };
const person2 = { age: 30 };
const mergedPerson = { ...person1, ...person2 }; // Merges both dictionaries
```

**Filtering Elements:** You can filter key-value pairs in a dictionary using the filter() method.

```
const person = { name: 'John', age: 30, job: 'Engineer' };
const filteredPerson = Object.keys(person)
  .filter(key => key !== 'age')
  .reduce((obj, key) => {
    obj[key] = person[key];
    return obj;
  }, {});
```

**Get Value by Key:** You can access the value associated with a key using square brackets or the dot notation.

```
const person = { name: 'John', age: 30 };
const name = person['name']; // Access by key
const age = person.age; // Access by dot notation
```

**Getting Keys by Value:** To get all keys associated with a specific value, you can use a loop.

```
const person = { name: 'John', age: 30, job: 'Engineer' };
const keysWithValue = [];
for (const key in person) {
  if (person[key] === 30) {
    keysWithValue.push(key);
  }
}
```

**Getting a List of Keys:** You can obtain a list of keys in a dictionary using Object.keys().

```
const person = { name: 'John', age: 30 };
const keys = Object.keys(person); // Returns ['name', 'age']
```

**Getting a List of Values:** To get a list of values in a dictionary, you can use Object.values().

```
const person = { name: 'John', age: 30 };
const values = Object.values(person); // Returns ['John', 30]
```

**Grouping Collection:** You can group data into a dictionary by iterating through a collection and organizing it by a specific key.

```
const people = [
  { name: 'John', age: 30 },
  { name: 'Alice', age: 25 },
  { name: 'Bob', age: 30 }
];

const groupedByAge = {};

people.forEach(person => {
  if (!groupedByAge[person.age]) {
    groupedByAge[person.age] = [];
  }
  groupedByAge[person.age].push(person);
});
```

**Iterating Over a Dictionary:** You can iterate over key-value pairs in a dictionary using a for...in loop.

```
const person = { name: 'John', age: 30 };
for (const key in person) {
  const value = person[key];
  // Do something with key and value
}
```

**Sort Dictionary by Keys:** To sort a dictionary by its keys, you can use Object.keys() to get the keys, sort them, and then create a new dictionary based on the sorted keys.

```
const person = { name: 'John', age: 30, job: 'Engineer' };
const sortedPerson = Object.keys(person)
  .sort()
  .reduce((obj, key) => {
    obj[key] = person[key];
    return obj;
  }, {});
```

**Sort Dictionary by Values:** To sort a dictionary by its values, you can use Object.entries() to get key-value pairs, sort them by values, and then create a new dictionary based on the sorted key-value pairs.

```
const person = { name: 'John', age: 30, job: 'Engineer' };
const sortedPerson = Object.entries(person)
  .sort((a, b) => a[1] - b[1]) // Sort by values
  .reduce((obj, [key, value]) => {
    obj[key] = value;
    return obj;
  }, {});
```

### Iterators:

**Reverse Iterator:** To create a reverse iterator, you can use a for...of loop in combination with the reverse() method to iterate over an array in reverse order.

```
const numbers = [1, 2, 3, 4, 5];
for (const num of numbers.reverse()) {
  console.log(num); // Prints 5, 4, 3, 2, 1
}
```

**Simple Iterator:** A simple iterator can be created using a for...of loop to iterate over the elements of an iterable (e.g., an array).

```
const fruits = ['apple', 'banana', 'cherry'];
for (const fruit of fruits) {
  console.log(fruit);
}
// apple
// banana
// cherry
```

### Queue (FIFO):

In JavaScript, you can implement a queue using an array. To add elements to the end (enqueue) and remove elements from the beginning (dequeue), you can use the push() and shift() methods, respectively.

```
const queue = [];
queue.push('item1'); // Enqueue item1
queue.push('item2'); // Enqueue item2
const dequeuedItem = queue.shift(); // Dequeue item1
```

### Sets:

**Adding and Removing Elements:** You can add elements to a Set using the add() method and remove elements using the delete() method.

```
const colors = new Set();
colors.add('red');
colors.add('blue');
colors.delete('red'); // Removes 'red' from the Set
```

**Converting a Set:** You can convert a Set to an array using the spread operator (...) or the Array.from() method.

```
const colors = new Set(['red', 'blue', 'green']);
const colorArray = [...colors]; // Converts to an array
```

**Filtering Elements:** You can filter elements in a Set using the forEach() method and a callback function.

```
const numbers = new Set([1, 2, 3, 4, 5]);
const evenNumbers = new Set();
numbers.forEach(num => {
  if (num % 2 === 0) {
    evenNumbers.add(num);
  }
});
```

**Iterating Over a Set:** You can iterate over the elements of a Set using a for...of loop.

```
const fruits = new Set(['apple', 'banana', 'cherry']);
for (const fruit of fruits) {
  console.log(fruit);
}
```

**Search for an Element:** You can check if an element exists in a Set using the has() method.

```
const colors = new Set(['red', 'blue', 'green']);
const hasBlue = colors.has('blue'); // Returns true
```

**Set Comparison:** You can compare two Sets for equality by converting them to arrays and comparing the arrays.

```
const set1 = new Set(['a', 'b', 'c']);
const set2 = new Set(['c', 'b', 'a']);
const areEqual = JSON.stringify([...set1]) === JSON.stringify([...set2]); // Compares element values
```

**Sets Initialization:** You can initialize a Set with values using the Set constructor.

```
const fruits = new Set(['apple', 'banana', 'cherry']);
```

**Sets Operations:** Sets support various set operations such as union, intersection, and difference.

```
const set1 = new Set([1, 2, 3]);
const set2 = new Set([3, 4, 5]);

// Union
const unionSet = new Set([...set1, ...set2]); // Contains {1, 2, 3, 4, 5}

// Intersection
const intersectionSet = new Set([...set1].filter(x => set2.has(x))); // Contains {3}

// Difference
const differenceSet = new Set([...set1].filter(x => !set2.has(x))); // Contains {1, 2}
```

**Sorted Set:** JavaScript Sets are inherently unordered. To create a sorted set, you can convert the Set to an array, sort it, and then create a new Set.

```
const numbers = new Set([5, 2, 8, 1, 3]);
const sortedSet = new Set([...numbers].sort((a, b) => a - b));
```

**Sorting of Elements:** To sort the elements of a Set, you can first convert it to an array and then use the sort() method.

```
const colors = new Set(['red', 'blue', 'green']);
const sortedColors = [...colors].sort();
```

### Stacks (LIFO)

In JavaScript, you can implement a stack using an array. To add elements to the end (push) and remove elements from the end (pop), you can use the push() and pop() methods, respectively.

```
const stack = [];
stack.push('item1'); // Pushes item1 onto the stack
stack.push('item2'); // Pushes item2 onto the stack
const poppedItem = stack.pop(); // Pops item2 from the stack
```

## Control Flow

### Conditional Statements

If/Else Statements
Complex Conditions
Ternary Operator
Switch/Case Statements
Different Types of Values
Simple Conditions
Without the `break` Operator

### Interruption of Control Flow:

Break Statement
Continue Statement
Return Statement
Labeled Statement

### Loops:

Do-While Loop

- For Loop
- For-In Loop
- For-Of Loop
- ForEach Loop
- While Loop
- Endless Loop

### Other Operations:

- Debugger Statement
- With Statement

### Enumerations

- Base Member Value
- Base Type
- Conversion from a String
- Converting to a String
- Definition and Initialization
- Enum Comparison
- Explicitly Set Base Value
- Get the List of Values
- Initializing from a Base Value

### Exceptions Handlin

- Catch All Exceptions
- Catch a Specific Exception
- Define an Exception Type
- Guaranteed Code Execution
- Method Throwing an Exception
- Re-Throw Exceptions
- Throw an Exception

### Extensions

- Adding Object Methods
- Adding Properties
- Adding Type Methods
- Simple Types Extension

### Functions

- Array of Parameters
- In/Out Parameters
- Multiple Return Values
- Optional Parameter Values
- Recursion
- Variable Parameters
- With Return Value
- Without Any Parameters
- Without Any Return Value

### Generic Types

- Generic Classes
- Generic Methods
- Substitution Principle

### Initializing of Types

- Classes
  - With a Constructor
  - Without Any Constructor
- Collections
  - Arrays
  - Dictionaries
  - Set

### Differences Between `var` and `let`

### Enumerations

- Simple Types
- Structures
  - Without Any Constructor
- Interfaces
  - Conformance Checking (is, as)
  - Constructor Requirements
  - Declaration and Initialization
  - Interfaces Collection
  - Interfaces Inheritance
  - Methods Requirements
  - Properties Requirements

### Lambda Expressions

- Capture of Variables
- Currying
- Function as a Parameter
- Function as a Return Value
- Memoization
- Memoization (Recursive)
- Modify Captured Variable
- Recursion
- With Multiple Operators
- With Multiple Parameters
- With One Parameter
- Without Return Value

### Multi-Threaded Operations

- Asynchronous Call
- Asynchronous Call with a Result
- Error Handling
- Keywords `async` and `await`
- Start of a New Thread
- Start of a New Thread and Waiting
- Operators Overloading

### Design Patterns

- **Behavioral Patterns**
  - Chain of Responsibility
  - Command
  - Interpreter
  - Iterator
  - Mediator
  - Memento
  - Observer
  - State
  - Strategy
  - Template Method
  - Visitor
- **Creational Patterns**
  - Abstract Factory
  - Builder
  - Factory Method
  - Prototype
  - Singleton
- **Structural Patterns**
  - Adapter (Composition)
  - Adapter (Inheritance)
  - Bridge
  - Composite
  - Decorator
  - Facade
  - Flyweight
  - Proxy

### Regular Expressions

- Check Match String
- Check Match Whole String
- Named Groups
- Regular Expression Options
- Replacement of the Match
- Replacement Using a Function
- Search All Matches
- Search for a Match

### Structures (Records)

- Constants
- Constructors
- Definition and Initialization
- Fields and Properties
- Methods
- Structure Inside the Structure
- Type Members

### Universal (Dynamic) Types

- Call Type Members
- Initialization
- Return Value

### Work with Color

- Color to HTML Color
- Color to RGB
- HTML Color to RGB
- RGB to Color

### Work with Database (DB)

- Connect to the DB
  - Connect to Firebird
  - Connect to MySQL
  - Connect to Oracle
  - Connect to PostgreSQL
  - Connect to SQL Server
  - Connect to SQLite
- Execute SQL Command
- Execute SQL Query
- SQL Query with Parameters

### Work with Files

- **Archives**
  - Packing a Zip File
  - Packing a Zip File with a Password
  - Unpacking a Zip File
- **Basic Operations**
  - Check If the File Exists
  - Copy a Directory
  - Create a Directory
  - Delete a Directory
  - Delete a Directory with Data
  - Delete a File
  - File Copying
  - File Moving
  - Get the Working Directory
  - Getting File Properties
  - List of Files in the Directory
- **Binary Files**
  - Read Array from a File
  - Read Dictionary from a File
  - Reading a Binary File
  - Write Array to a File
  - Write Dictionary to a File
  - Writing a Binary File
- **Text Files**
  - Append Text to a File
  - Read File Line by Line
  - Read from a File
  - Write to a File
- **XML Files**
  - Reading an XML File

### Work with Simple Types

- **Boolean**
  - Conversion from a String
  - Converting to a String
  - Getting Values
  - Logical Operations
- **Character Type**
  - Converting to a Number and Back
  - Converting to a String
  - Escape Characters
  - Getting from a String
- **Date and Time**
  - Comparison of Dates
  - Conversion from a String
  - Converting to a String
  - Date Changing
  - Date Initialization
  - Getting the Current Date
  - Getting Year, Month, Day
  - The Interval Between Dates
- **Nullable Types**
  - Checking Presence of a Value
  - Initialization
- **Numbers**
  - **Double and Float**
    - Arithmetic Operations
    - Conversion from a String
    - Converting to a String
    - Converting to Integer
    - Getting Random Values
    - Rounding and Truncating
  - **Integers**
    - Arithmetic Operations
    - BigInteger
    - Bitwise Operations
    - Conversion from a String
    - Converting to a String
    - Getting Random Values
    - Numerical System
  - **Mathematical Operations**
    - Decimal Logarithm
    - Exponentiation
    - Logarithm
    - Sine, Cosine, and Tangent
    - Square Root
    - Min and Max Values
- **Strings**
  - Change the Case of Characters
  - Character Replacement
  - Characters Count
  - Converting to a Number
  - Empty Strings
  - Escaping Characters
  - Getting Substring
  - Iterating Over a String
  - Removing Spaces
  - Replace Multiple Characters
  - Split Into an Array
  - String Multiplication
  - String Padding
  - Strings Comparison
  - Strings Concatenating
  - String Interpolation
  - String List Concatenating
  - Substring Index
  - Substring Inserting
  - Substring Removing
  - Substring Replacement
  - Substring Searching
- **Tuple**
  This structure should help organize your JavaScript recipes guide effectively.
