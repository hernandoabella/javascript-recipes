# JavaScript Recipes üë®‚Äçüç≥

## Table of Contents

### Algorithms

- **Sorting**
  - Bubble Sort
  - Counting Sort
  - Merge Sort
  - Quick Sort
  - Radix Sort
- **Searching**
  - Binary Search
  - Fast Linear Search
  - Interpolation Search
  - Linear Search

### Arrays and Collections

- **Arrays**
  - Adding and Removing Elements
  - Array Copying
  - Array Length
  - Array with Default Value
  - Comparing Arrays
  - Arrays Initialization
  - Arrays Merging
  - Checking Equality of Arrays
  - Converting an Array
  - Dynamic Arrays
  - Filtering Elements
  - Finding an Array Element
  - Getting Min and Max Values
  - Getting Part of an Array
  - Getting Unique Values
  - Iterating Over an Array
  - Iterating Over an Array with Index
  - Sorting of Elements
  - `every()` and `some()` Methods
- **Dictionaries**
  - Adding and Removing Elements
  - Amount of Elements
  - Checking Presence of a Key
  - Converting a Dictionary
  - Default Value
  - Dictionaries Initialization
  - Dictionary Merge
  - Filtering Elements
  - Get Value by Key
  - Getting Keys by Value
  - Getting a List of Keys
  - Getting a List of Values
  - Grouping Collection
  - Iterating Over a Dictionary
  - Sort Dictionary by Keys
  - Sort Dictionary by Values
- **Iterators**
  - Reverse Iterator
  - Simple Iterator
- **Queue (FIFO)**
- **Sets**
  - Adding and Removing Elements
  - Converting a Set
  - Filtering Elements
  - Iterating Over a Set
  - Search for an Element
  - Set Comparison
  - Sets Initialization
  - Sets Operations
  - Sorted Set
  - Sorting of Elements
- **Stacks (LIFO)**

### Control Flow

- **Conditional Statements**
  - If/Else Statements
    - Complex Conditions
    - Ternary Operator
  - Switch/Case Statements
    - Different Types of Values
    - Simple Conditions
    - Without the `break` Operator
- **Interruption of Control Flow**
  - Break Statement
  - Continue Statement
  - Return Statement
  - Labeled Statement
- **Loops**
  - Do-While Loop
  - For Loop
  - For-In Loop
  - For-Of Loop
  - ForEach Loop
  - While Loop
  - Endless Loop
- **Other Operations**
  - Debugger Statement
  - With Statement

### Enumerations

- Base Member Value
- Base Type
- Conversion from a String
- Converting to a String
- Definition and Initialization
- Enum Comparison
- Explicitly Set Base Value
- Get the List of Values
- Initializing from a Base Value

### Exceptions Handlin

- Catch All Exceptions
- Catch a Specific Exception
- Define an Exception Type
- Guaranteed Code Execution
- Method Throwing an Exception
- Re-Throw Exceptions
- Throw an Exception

### Extensions

- Adding Object Methods
- Adding Properties
- Adding Type Methods
- Simple Types Extension

### Functions

- Array of Parameters
- In/Out Parameters
- Multiple Return Values
- Optional Parameter Values
- Recursion
- Variable Parameters
- With Return Value
- Without Any Parameters
- Without Any Return Value

### Generic Types

- Generic Classes
- Generic Methods
- Substitution Principle

### Initializing of Types

- Classes
  - With a Constructor
  - Without Any Constructor
- Collections
  - Arrays
  - Dictionaries
  - Set

### Differences Between `var` and `let`

### Enumerations

- Simple Types
- Structures
  - Without Any Constructor
- Interfaces
  - Conformance Checking (is, as)
  - Constructor Requirements
  - Declaration and Initialization
  - Interfaces Collection
  - Interfaces Inheritance
  - Methods Requirements
  - Properties Requirements

### Lambda Expressions

- Capture of Variables
- Currying
- Function as a Parameter
- Function as a Return Value
- Memoization
- Memoization (Recursive)
- Modify Captured Variable
- Recursion
- With Multiple Operators
- With Multiple Parameters
- With One Parameter
- Without Return Value

### Multi-Threaded Operations

- Asynchronous Call
- Asynchronous Call with a Result
- Error Handling
- Keywords `async` and `await`
- Start of a New Thread
- Start of a New Thread and Waiting
- Operators Overloading

### Design Patterns

- **Behavioral Patterns**
  - Chain of Responsibility
  - Command
  - Interpreter
  - Iterator
  - Mediator
  - Memento
  - Observer
  - State
  - Strategy
  - Template Method
  - Visitor
- **Creational Patterns**
  - Abstract Factory
  - Builder
  - Factory Method
  - Prototype
  - Singleton
- **Structural Patterns**
  - Adapter (Composition)
  - Adapter (Inheritance)
  - Bridge
  - Composite
  - Decorator
  - Facade
  - Flyweight
  - Proxy

### Regular Expressions

- Check Match String
- Check Match Whole String
- Named Groups
- Regular Expression Options
- Replacement of the Match
- Replacement Using a Function
- Search All Matches
- Search for a Match

### Structures (Records)

- Constants
- Constructors
- Definition and Initialization
- Fields and Properties
- Methods
- Structure Inside the Structure
- Type Members

### Universal (Dynamic) Types

- Call Type Members
- Initialization
- Return Value

### Work with Color

- Color to HTML Color
- Color to RGB
- HTML Color to RGB
- RGB to Color

### Work with Database (DB)

- Connect to the DB
  - Connect to Firebird
  - Connect to MySQL
  - Connect to Oracle
  - Connect to PostgreSQL
  - Connect to SQL Server
  - Connect to SQLite
- Execute SQL Command
- Execute SQL Query
- SQL Query with Parameters

### Work with Files

- **Archives**
  - Packing a Zip File
  - Packing a Zip File with a Password
  - Unpacking a Zip File
- **Basic Operations**
  - Check If the File Exists
  - Copy a Directory
  - Create a Directory
  - Delete a Directory
  - Delete a Directory with Data
  - Delete a File
  - File Copying
  - File Moving
  - Get the Working Directory
  - Getting File Properties
  - List of Files in the Directory
- **Binary Files**
  - Read Array from a File
  - Read Dictionary from a File
  - Reading a Binary File
  - Write Array to a File
  - Write Dictionary to a File
  - Writing a Binary File
- **Text Files**
  - Append Text to a File
  - Read File Line by Line
  - Read from a File
  - Write to a File
- **XML Files**
  - Reading an XML File

### Work with Simple Types

- **Boolean**
  - Conversion from a String
  - Converting to a String
  - Getting Values
  - Logical Operations
- **Character Type**
  - Converting to a Number and Back
  - Converting to a String
  - Escape Characters
  - Getting from a String
- **Date and Time**
  - Comparison of Dates
  - Conversion from a String
  - Converting to a String
  - Date Changing
  - Date Initialization
  - Getting the Current Date
  - Getting Year, Month, Day
  - The Interval Between Dates
- **Nullable Types**
  - Checking Presence of a Value
  - Initialization
- **Numbers**
  - **Double and Float**
    - Arithmetic Operations
    - Conversion from a String
    - Converting to a String
    - Converting to Integer
    - Getting Random Values
    - Rounding and Truncating
  - **Integers**
    - Arithmetic Operations
    - BigInteger
    - Bitwise Operations
    - Conversion from a String
    - Converting to a String
    - Getting Random Values
    - Numerical System
  - **Mathematical Operations**
    - Decimal Logarithm
    - Exponentiation
    - Logarithm
    - Sine, Cosine, and Tangent
    - Square Root
    - Min and Max Values
- **Strings**
  - Change the Case of Characters
  - Character Replacement
  - Characters Count
  - Converting to a Number
  - Empty Strings
  - Escaping Characters
  - Getting Substring
  - Iterating Over a String
  - Removing Spaces
  - Replace Multiple Characters
  - Split Into an Array
  - String Multiplication
  - String Padding
  - Strings Comparison
  - Strings Concatenating
  - String Interpolation
  - String List Concatenating
  - Substring Index
  - Substring Inserting
  - Substring Removing
  - Substring Replacement
  - Substring Searching
- **Tuple**
  This structure should help organize your JavaScript recipes guide effectively.

### Algorithms

Algorithms are step-by-step procedures for solving specific problems or performing tasks. They are crucial in computer science and programming for efficient problem-solving.

**Bubble Sort:** Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.

```
function bubbleSort(arr) {
  const len = arr.length;
  let swapped;

  do {
    swapped = false;

    for (let i = 0; i < len - 1; i++) {
      if (arr[i] > arr[i + 1]) {
        // Swap the elements
        const temp = arr[i];
        arr[i] = arr[i + 1];
        arr[i + 1] = temp;
        swapped = true;
      }
    }
  } while (swapped);

  return arr;
}

// Example usage:
const unsortedArray = [64, 34, 25, 12, 22, 11, 90];
const sortedArray = bubbleSort(unsortedArray);
console.log(sortedArray); // [ 11, 12, 22, 25, 34, 64, 90 ]
```

**Counting Sort:** Counting Sort is an integer sorting algorithm that works by counting the number of occurrences of each element and using that information to place elements in sorted order.

```
function countingSort(arr) {
  // Find the maximum element in the input array
  const max = Math.max(...arr);

  // Create an array to store the count of each element
  const countArray = new Array(max + 1).fill(0);

  // Count the occurrences of each element in the input array
  for (let i = 0; i < arr.length; i++) {
    countArray[arr[i]]++;
  }

  // Reconstruct the sorted array using the count information
  const sortedArray = [];
  for (let i = 0; i < countArray.length; i++) {
    while (countArray[i] > 0) {
      sortedArray.push(i);
      countArray[i]--;
    }
  }

  return sortedArray;
}

// Example usage:
const unsortedArray = [4, 2, 2, 8, 3, 3, 1];
const sortedArray = countingSort(unsortedArray);
console.log(sortedArray); // [ 1, 2, 2, 3, 3, 4, 8 ]
```

**Merge Sort:** Merge Sort is a divide-and-conquer sorting algorithm that divides an array into smaller sub-arrays, sorts them, and then merges them back together.

```
function mergeSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  // Split the input array into two halves
  const middle = Math.floor(arr.length / 2);
  const leftHalf = arr.slice(0, middle);
  const rightHalf = arr.slice(middle);

  // Recursively sort the two halves
  const sortedLeft = mergeSort(leftHalf);
  const sortedRight = mergeSort(rightHalf);

  // Merge the sorted halves back together
  return merge(sortedLeft, sortedRight);
}

function merge(left, right) {
  let result = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // Compare elements from both halves and add the smaller one to the result
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex]);
      leftIndex++;
    } else {
      result.push(right[rightIndex]);
      rightIndex++;
    }
  }

  // Concatenate any remaining elements from both halves (if any)
  return result.concat(left.slice(leftIndex), right.slice(rightIndex));
}

// Example usage:
const unsortedArray = [38, 27, 43, 3, 9, 82, 10];
const sortedArray = mergeSort(unsortedArray);
console.log(sortedArray);
```

**Quick Sort:** Quick Sort is another divide-and-conquer sorting algorithm that works by selecting a "pivot" element and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot.

```
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  // Select a pivot element (usually the first or last element)
  const pivot = arr[Math.floor(arr.length / 2)];

  // Divide the array into two sub-arrays: elements less than the pivot and elements greater than the pivot
  const left = arr.filter((element) => element < pivot);
  const middle = arr.filter((element) => element === pivot);
  const right = arr.filter((element) => element > pivot);

  // Recursively sort the sub-arrays and concatenate them
  return quickSort(left).concat(middle, quickSort(right));
}

// Example usage:
const unsortedArray = [38, 27, 43, 3, 9, 82, 10];
const sortedArray = quickSort(unsortedArray);
console.log(sortedArray); // [ 3, 9, 10, 27, 38, 43, 82 ]
```

**Radix Sort:** Radix Sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by individual digits that share the same significant position.

```
function radixSort(arr) {
  const max = Math.max(...arr);
  const maxDigitCount = getMaxDigitCount(max);

  for (let digitPlace = 0; digitPlace < maxDigitCount; digitPlace++) {
    const digitBuckets = Array.from({ length: 10 }, () => []);

    for (let i = 0; i < arr.length; i++) {
      const digit = getDigit(arr[i], digitPlace);
      digitBuckets[digit].push(arr[i]);
    }

    arr = [].concat(...digitBuckets);
  }

  return arr;
}

// Helper function to get the maximum number of digits in an array of integers
function getMaxDigitCount(num) {
  if (num === 0) return 1;
  return Math.floor(Math.log10(Math.abs(num))) + 1;
}

// Helper function to get the digit at a given place value
function getDigit(num, place) {
  return Math.floor(Math.abs(num) / Math.pow(10, place)) % 10;
}

// Example usage:
const unsortedArray = [170, 45, 75, 90, 802, 24, 2, 66];
const sortedArray = radixSort(unsortedArray);
console.log(sortedArray); // [ 2, 24, 45, 66, 75, 90, 170, 802 ]
```
